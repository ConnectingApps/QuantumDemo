# QuantumDemo
A demonstration to explain quantum computing with Q# . This solution is intended to be used for training purposes.  If you want to compile this solution make, sure you install the [Quantum Development Kit](https://docs.microsoft.com/en-us/quantum/quantum-installconfig) first and try to compile [this solution](https://github.com/Microsoft/QuantumKatas/blob/master/README.md) before using this one. There are several projects to demo something which can be a language feature, a quantum operation or even both. 

## PauliOperator  ##

The PauliOperator project demonstrates a typical [Pauli operator](https://docs.microsoft.com/nl-nl/quantum/libraries/prelude?view=qsharp-preview#pauli-operators): the X operation. This can be used for several reasons. A typical problem with quantum computing is that there is no way to clone your data because. This problem is called the [No-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem). But some way or another we need to set a value. We do this by using a qbit, measure its value and if the measurement is different from expected switch it by rotating 180 degrees. Once it has been set, we can repeat this X operation. If the number of X operations is even (for example 2), the value has not changed. A 360 degree rotation does not change a position.

In Q#, we can even create a function for doing something two times and use functions as arguments (as typical in functional programming). This is also demonstrated. We do this by [partial application](https://docs.microsoft.com/nl-nl/quantum/quantum-techniques-2-operationsandfunctions?view=qsharp-preview#partially-applying-operations-and-functions). The [bound variables](https://en.wikipedia.org/wiki/Free_variables_and_bound_variables) are given in the call. The free variables are replaced by an underscore.

The output shows that the difference between even and odd number of X operations is as expected. If the created method does a duplicate X operation, the value is always the same.

## RandomGenerator, using super position ##

The RandomGenerator project demonstrates a random generator. A number of booleans is created. Based on this number of booleans, we can create an integer. Each boolean can be considerd as a bit. With a combination of bits, we can describe and calculate and integer. Similar to [this](https://en.wikipedia.org/wiki/Binary_number#Leibniz_and_the_I_Ching). This is really old mathematics and classical logic. We also need a way to randomize. Therefore, each boolean (to be considered as a bit) needs to have a random value. We do this by putting a qbit in a [superposition state](https://en.wikipedia.org/wiki/Quantum_superposition) using [Hadamard gate operation](https://en.wikipedia.org/wiki/Hadamard_transform#Hadamard_gate_operations); check the code and look for the [H call](https://github.com/ConnectingApps/QuantumDemo/blob/master/RandomGenerator/Operation.qs#L56). When measuring the qbit, we cannot predict the value. It is random. In traditional computing, random generators try to be as random as possible. Quantum computers use fundamental (laws of) physics to generate random numbers. Nature has random behavior [by itself](https://www.nist.gov/news-events/news/2018/04/nists-new-quantum-method-generates-really-random-numbers). So this is a real random generator. 


